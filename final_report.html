<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">


<head>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Real-Time Atmospheric Scattering</title>
  <style>
    code {
      white-space: pre-wrap;
    }

    span.smallcaps {
      font-variant: small-caps;
    }

    div.columns {
      display: flex;
      gap: min(4vw, 1.5em);
    }

    div.column {
      flex: auto;
      overflow-x: auto;
    }

    div.hanging-indent {
      margin-left: 1.5em;
      text-indent: -1.5em;
    }

    ul.task-list {
      list-style: none;
    }

    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }

    .display.math {
      display: block;
      text-align: center;
      margin: 0.5rem auto;
    }
  </style>
  <link rel="stylesheet" href="icg_report.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>

<body>
  <header id="title-block-header">
    <h1 class="title">Real-Time Atmospheric Scattering</h1>
  </header>
  <figure>
    <img src="images/atmosphere_from_planet.jpg" width="800" alt="atmosphere from planet" />
    <figcaption aria-hidden="true"></figcaption>
  </figure>
  <h1 id="Abstract">Abstract</h1>
  <p>Our project presents an immersive, real-time scattering atmosphere simulation in the Unity game engine,
    leveraging the visual depth and precision of GLSL shaders to create photorealistic atmospheric effects.

    The project models procedural planets using Blender, which are subsequently imported into Unity for a
    seamless integration with the overall system.

    In addition, a comprehensive celestial movement system is implemented through C# scripting, simulating
    authentic planetary motion around the sun and rotation. To complement this, we have also incorporated an
    exploratory spaceship feature, designed to traverse this expansive space, providing the user with the
    opportunity to closely explore the crafted planets and their respective atmospheres.
  </p>

  <h1 id="Technical approach">Technical Approach</h1>
  <h2 id="Atmosphere Scattering Shader">Atmosphere Scattering Shader</h2>
  <ul>
    <p> Text</p>
    <li>
      <p>Point</p>
    </li>

    <h2 id="Procedural-Planets">Procedural Planets</h2>
    <ul>
      <li>
        <p>Our procedural planet development process was largely inspired by the tutorial
          provided by Michele Vidulis, although we decided to omit certain aspects such as the
          atmosphere, clouds, trees, and more complex textures for the sake of simplicity.</p>
      </li>

      <li>
        <p>For land creation, we started with a basic sphere and applied a noise algorithm,
          which was then subtracted from the original sphere. This resulted in a varied terrain
          shape on the surface of our planet. The noise function used in this process has multiple parameters,
          including resolution, scale, and depth, which can be adjusted to form different types of land surfaces.</p>
      </li>

      <img src="images/procedural_planets_1.png" width="800" alt="" />

      <li>
        <p>The oceanic part of the planet is a completely separate entity, which we created from a box mesh
          and a subdivision surface. This method gives us a better polygon distribution compared to a UV sphere when
          we create the ocean material.</p>
      </li>

      <img src="images/procedural_planets_2.png" width="800" alt="" />

      <li>
        <p>To complete the ocean, we implemented an ocean shader. The ocean and the continents are joined using
          a join geometry operation. We then added a proximity node, using the continents sphere as the target. We
          stored
          the resulting proximity mask in a variable called "ocean depth". This whole process produced a convincing
          representation
          of an ocean on the planet.</p>
      </li>

      <img src="images/procedural_planets_3.png" width="800" alt="" />

    </ul>
    <h2 id="Realistic Earth Textures">Realistic Earth Textures</h2>
    <li>
      <p>Initially, the aim was to create a more realistic representation of planets. High definition textures of Earth
        were identified for this purpose. Interestingly, nighttime textures were also available, sparking the idea of
        incorporating a day-night cycle. Each texture could be utilized depending on the lighting conditions.</p>
    </li>

    <div style="display: flex; justify-content: center;">
      <img src="images/2k_earth_daymap.jpg" width="500" alt="" style="margin-right: 20px;" />
      <img src="images/2k_earth_nightmap.jpg" width="500" alt="" style="margin-left: 20px;" />
    </div>

    <li>
      <p>The day-night cycle is controlled using a shader "Custom/EarthShader" that processes both daytime and nighttime
        textures based on the direction of light. This shader employs two primary functions: a vertex shader and a
        fragment shader.</p>
    </li>

    <li>
      <p>The vertex shader, "vert", transforms the vertex position to clip space, passes through the texture
        coordinates, transforms the normal vector to world space, calculates world space position, calculates direction
        towards the light source, and calculates direction towards the viewer.</p>
    </li>

    <li>
      <p>The fragment shader, "frag", then samples both daytime and nighttime textures. It calculates the diffuse
        lighting factor to smoothly transition between day and night. This factor is used to linearly interpolate
        between the night and day color. </p>
    </li>

    <li>
      <p>When on the darker side of the object, emission is calculated based on the nighttime texture's green channel
        and light brightness. Emission is rendered as emissive objects with a color varying from yellowish to whitish,
        depending on the intensity of the lights. This mimics the look of city lights as seen from space at night. </p>
    </li>

    <li>
      <p>The shader checks each pixel on the dark side of the texture to determine if it represents a light source. If
        it does, the shader renders the pixel as an emissive object, with its color depending on the intensity of the
        light. This results in a gradient from white (for more intense lights) to yellow (for less intense lights).</p>
    </li>

    <li>
      <p>By utilizing these methods, the shader creates a dynamic visual effect that provides the player with a more
        realistic and immersive experience of day-night cycles and the intensity of city lights on Earth.</p>
    </li>

    <div style="display: flex; justify-content: center;">
      <img src="images/earth_emissive_night.png" width="500" alt="" style="margin-right: 20px;" />
    </div>

<ul>
  <h2 id="Planet Movements">Planet Movements</h2>
  <li>
    <p>To simulate gravity, we use Newton's Universal Law of Gravitation:</p>
    <div style="text-align: center;">
      \( F = G \frac{{m_1 \cdot m_2}}{{r^2}} \)
    </div>
    <p>This equation is applied in the <code>ApplyGravity()</code> function. The direction and
      magnitude of the gravitational force are calculated and applied to the Rigidbody of the planet.</p>

    <p>We simplify this model by assuming that the gravitational interaction is only significant between the sun
      and the individual planet. This allows us to overlook the relatively minor effects of the planets on each other's movements.</p>
  </li>

  <li>
    <p>Furthermore, we have implemented an option to adjust the eccentricity of the orbit. This eccentricity value is used in the
      <code>SetInitialOrbitalVelocity()</code> function to set the initial speed of the planet, allowing for non-circular (elliptical) orbits.
    </p>
  </li>

  <li>
    <p>We also have an option that automatically sets the planet into a stable orbit, if possible. This is accomplished
      by setting the initial velocity of the planet such that the gravitational pull from the sun is balanced by the centripetal force
      required for a circular orbit.</p>
  </li>

  <li>
    <p>Finally, the rotation of the planet around its axis is set up in the <code>Start()</code> function. Here, we assign an angular
      velocity to the planet's Rigidbody based on the specified rotational speed.</p>
  </li>
</ul>


  </ul>
  <h2 id="Flight Simulator">Flight Simulator</h2>
  <li>
    <p>The spaceship controller script is used to simulate the flight mechanics of a spaceship in the game environment.
    </p>
  </li>

  <li>
    <p>The spaceship is controlled through keyboard input. The keys W and S are used to move the spaceship forward and
      backward, respectively. Likewise, the keys A and D are used to move the spaceship to the left and right,
      respectively. These controls are handled in the <code>FixedUpdate()</code> function of the script.</p>
  </li>

  <li>
    <p>In addition to the linear movement, the spaceship's orientation is controlled by the mouse's movements on the X
      and Y axes. This gives the player the ability to look around the spaceship's cockpit and control its pitch and
      yaw. These controls are also handled in the <code>FixedUpdate()</code> function of the script.</p>
  </li>

  <li>
    <p>The speed of the spaceship is controlled using acceleration. The desired velocity is determined based on the
      input controls, then the current velocity is interpolated towards this desired velocity at a rate determined by
      the acceleration. This results in smooth movement and changes in speed.</p>
  </li>

  <li>
    <p>As the spaceship speeds up, the field of view of the spaceship's camera is increased to give the effect of
      rushing past the environment. This is done by linearly interpolating between a minimum and maximum field of view
      based on the spaceship's speed. When the spaceship is at its maximum speed, the field of view is at its maximum.
      Conversely, when the spaceship is at a standstill, the field of view is at its minimum. This creates a dynamic
      visual effect that provides the player with a sense of speed and movement.</p>
  </li>

  <li>
    <p>All of these mechanics are initialized in the <code>Start()</code> function, where the Rigidbody and Camera
      components of the spaceship are retrieved, and the cursor is hidden and locked to the center of the screen for
      optimal control.</p>
  </li>



  <h1 id="Results">Results</h1>

  <img src="images/result1.png" width="400" alt="" />


  <h1 id="Contributions">Contributions</h1>
  <ul>
    <li>Initially, we faced several challenges in utilizing the Unity engine due to our unfamiliarity with it.
      However, since then our progress has noticeably improved and we feel more confortable with the engine.</li>
  </ul>

  </ul>
  <h1 id="resources">Resources</h1>
  <p>[1] Nishita 1993, Display of The Earth Taking into Account
    Atmospheric Scattering -<a href="url">http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf</a></p>
  <p>[2] O’Neil, Accurate Atmospheric Scattering -
    <a
      href="url">https://developer.nvidia.com/gpugems/gpugems2/part-ii-shading-lighting-and-shadows/chapter-16-accurate-atmospheric-scattering</a>
  </p>
  <p>[3] Bruneton &amp; Neyret 2008, Precomputed Atmospheric Scattering -
    <a href="url">https://hal.inria.fr/inria-00288758/document</a>
  </p>
  <p>[4] Angular Diameter -
    <a href="url">https://www.astronomy.swin.edu.au/cosmos/A/Angular+Diameter</a>
  </p>
  <p>[5] A Qualitative and Quantitative Evaluation of 8 Clear Sky Models -
    <a href="url">https://arxiv.org/pdf/1612.04336.pdf</a>
  </p>
  <p>[6] Spectral rendering -
    <a href="url">https://en.wikipedia.org/wiki/Spectral_rendering</a>
  </p>
  <p>[7] Night/Day Earth and Sun textures -
    <a href="url">https://www.solarsystemscope.com/textures/</a>
  </p>
</body>

</html>